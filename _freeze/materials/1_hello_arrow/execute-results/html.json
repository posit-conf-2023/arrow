{
  "hash": "13f695b115096e17b0c778c7edc51d98",
  "result": {
    "markdown": "---\nfooter: \"[🔗 posit.io/arrow](https://posit-conf-2023.github.io/arrow)\"\nlogo: \"images/logo.png\"\nexecute:\n  echo: true\nformat:\n  revealjs: \n    theme: default\nengine: knitr\n---\n\n\n# Hello Arrow {#hello-arrow}\n\n## Poll: Arrow\n\n<br>\n\nHave you used or experimented with Arrow before today?\n\n-   A little\n-   A lot\n-   Not yet\n-   Not yet, but I have read about it!\n\n## Hello Arrow<br>Demo\n\n<br>\n\n![](images/logo.png){.absolute top=\"0\" left=\"250\" width=\"600\" height=\"800\"}\n\n## Some \"Big\" Data\n\n![](images/nyc-taxi-homepage.png){.absolute left=\"200\" width=\"600\"}\n\n::: {style=\"font-size: 60%; margin-top: 550px; margin-left: 200px;\"}\n<https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page>\n:::\n\n## NYC Taxi Data\n\n-   *big* NYC Taxi data set (\\~40GBs on disk)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nopen_dataset(\"s3://voltrondata-labs-datasets/nyc-taxi\") |>\n  filter(year %in% 2012:2021) |>\n  write_dataset(here::here(\"data/nyc-taxi\"), partitioning = c(\"year\", \"month\"))\n```\n:::\n\n\n-   *tiny* NYC Taxi data set (\\<1GB on disk)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndownload.file(url = \"https://github.com/posit-conf-2023/arrow/releases/download/v0.1/nyc-taxi-tiny.zip\",\n              destfile = here::here(\"data/nyc-taxi-tiny.zip\"))\n\nunzip(\n  zipfile = here::here(\"data/nyc-taxi-tiny.zip\"),\n  exdir = here::here(\"data/\")\n)\n```\n:::\n\n\n## posit Cloud ☁️\n\n<br>\n\n[posit.io/arrow-conf23-cloud](https://posit.cloud/spaces/397258/content/all?sort=name_asc)\n\n<br>\n\nOnce you have joined, navigate to Projects on the top menu.\n\n## Larger-Than-Memory Data\n\n<br>\n\n`arrow::open_dataset()`\n\n<br>\n\n`sources`: point to a string path or directory of data files (on disk or in a GCS/S3 bucket) and return an `Arrow Dataset`, then use `dplyr` methods to query it.\n\n::: notes\nArrow Datasets allow you to query against data that has been split across multiple files. This sharding of data may indicate partitioning, which can accelerate queries that only touch some partitions (files). Call open_dataset() to point to a directory of data files and return a Dataset, then use dplyr methods to query it.\n:::\n\n\n## NYC Taxi Dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(arrow)\n\nnyc_taxi <- open_dataset(here::here(\"data/nyc-taxi\"))\n```\n:::\n\n\n## NYC Taxi Dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi |> \n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1150352666\n```\n:::\n:::\n\n\n<br>\n\n1.15 billion rows 🤯\n\n## NYC Taxi Dataset: A question\n\nWhat percentage of taxi rides each year had more than 1 passenger?\n\n## NYC Taxi Dataset: A {dplyr} pipeline\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nnyc_taxi |>\n  filter(year %in% 2014:2017) |>\n  group_by(year) |>\n  summarise(\n    all_trips = n(),\n    shared_trips = sum(passenger_count > 1, na.rm = TRUE)\n  ) |>\n  mutate(pct_shared = shared_trips / all_trips * 100) |>\n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n   year all_trips shared_trips pct_shared\n  <int>     <int>        <int>      <dbl>\n1  2014 165114361     48816505       29.6\n2  2015 146112989     43081091       29.5\n3  2016 131165043     38163870       29.1\n4  2017 113495512     32296166       28.5\n```\n:::\n:::\n\n\n## NYC Taxi Dataset: A {dplyr} pipeline\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"4,13,14\"}\nlibrary(dplyr)\nlibrary(tictoc)\n\ntic()\nshared_rides <- nyc_taxi |>\n  filter(year %in% 2014:2017) |>\n  group_by(year) |>\n  summarise(\n    all_trips = n(),\n    shared_trips = sum(passenger_count > 1, na.rm = TRUE)\n  ) |>\n  mutate(pct_shared = shared_trips / all_trips * 100) |>\n  collect()\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.896 sec elapsed\n```\n:::\n:::\n\n\n## Your Turn\n\n1.  Calculate total number of rides for each month in 2019\n\n2.  About how long did this query of 1.15 billion rows take?\n\n➡️ [Hello Arrow Exercises Page](1_hello_arrow-exercises.html)\n\n## What is Apache Arrow?\n\n::: columns\n::: {.column width=\"50%\"}\n> A multi-language toolbox for accelerated data interchange and in-memory processing\n:::\n\n::: {.column width=\"50%\"}\n> Arrow is designed to both improve the performance of analytical algorithms and the efficiency of moving data from one system or programming language to another\n:::\n:::\n\n::: {style=\"font-size: 70%;\"}\n<https://arrow.apache.org/overview/>\n:::\n\n## Apache Arrow Specification\n\nIn-memory columnar format: a standardized, language-agnostic specification for representing structured, table-like data sets in-memory.\n\n<br>\n\n![](images/arrow-rectangle.png){.absolute left=\"200\"}\n\n## A Multi-Language Toolbox\n\n![](images/arrow-libraries-structure.png)\n\n## Accelerated Data Interchange\n\n![](images/data-interchange-with-arrow.png)\n\n## Accelerated In-Memory Processing\n\nArrow's Columnar Format is Fast\n\n![](images/columnar-fast.png){.absolute top=\"120\" left=\"200\" height=\"600\"}\n\n::: notes\nThe contiguous columnar layout enables vectorization using the latest SIMD (Single Instruction, Multiple Data) operations included in modern processors.\n:::\n\n## arrow 📦\n\n<br>\n\n![](images/arrow-r-pkg.png){.absolute top=\"0\" left=\"300\" width=\"700\" height=\"900\"}\n\n## arrow 📦\n\n![](images/arrow-read-write-updated.png)\n\n## Today\n\n-   Module 1: Larger-than-memory data manipulation with Arrow---Part I\n-   Module 2: Data engineering with Arrow\n-   Module 3: Larger-than-memory data manipulation with Arrow---Part II\n-   Module 4: In-memory workflows in R with Arrow\n\n<br>\n\nWe will also talk about Arrow data types, file formats, controlling schemas & more fun stuff along the way!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}