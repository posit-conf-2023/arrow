{
  "hash": "f04df3aea8f99566758ee7f98b2806d1",
  "result": {
    "markdown": "---\nfooter: \"[üîó posit.io/arrow](https://posit-conf-2023.github.io/arrow)\"\nlogo: \"images/logo.png\"\nexecute:\n  echo: true\nformat:\n  revealjs: \n    theme: default\nengine: knitr\n---\n\n\n# Data Manipulation---Part 2 {#data-manip-2}\n\n\n::: {.cell}\n\n:::\n\n\n# Joins\n\n## Joining a reference table\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvendors <- tibble::tibble(\n  code = c(\"VTS\", \"CMT\", \"DDS\"),\n  full_name = c(\n    \"Verifone Transportation Systems\",\n    \"Creative Mobile Technologies\",\n    \"Digital Dispatch Systems\"\n  )\n)\n\nnyc_taxi %>%\n  left_join(vendors, by = c(\"vendor_name\" = \"code\")) %>%\n  select(vendor_name, full_name, pickup_datetime) %>%\n  head(3) %>%\n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 √ó 3\n  vendor_name full_name                    pickup_datetime    \n  <chr>       <chr>                        <dttm>             \n1 CMT         Creative Mobile Technologies 2012-11-02 19:59:15\n2 CMT         Creative Mobile Technologies 2012-11-02 19:59:19\n3 CMT         Creative Mobile Technologies 2012-11-02 19:58:02\n```\n:::\n:::\n\n\n## Traps for the unwary\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi_zones <-\n  read_csv_arrow(here::here(\"data/taxi_zone_lookup.csv\")) %>%\n  select(location_id = LocationID,\n         borough = Borough)\n\nnyc_taxi_zones\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 265 √ó 2\n   location_id borough      \n         <int> <chr>        \n 1           1 EWR          \n 2           2 Queens       \n 3           3 Bronx        \n 4           4 Manhattan    \n 5           5 Staten Island\n 6           6 Staten Island\n 7           7 Queens       \n 8           8 Queens       \n 9           9 Queens       \n10          10 Queens       \n# ‚Ñπ 255 more rows\n```\n:::\n:::\n\n\n## Why didn't this work?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi |>\n  left_join(nyc_taxi_zones, by = c(\"pickup_location_id\" = \"location_id\")) |>\n  collect()\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `compute.arrow_dplyr_query()`:\n! Invalid: Incompatible data types for corresponding join field keys: FieldRef.Name(pickup_location_id) of type int64 and FieldRef.Name(location_id) of type int32\n```\n:::\n:::\n\n\n## Schema for the `nyc_taxi` table\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi$schema\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSchema\nvendor_name: string\npickup_datetime: timestamp[ms]\ndropoff_datetime: timestamp[ms]\npassenger_count: int64\ntrip_distance: double\npickup_longitude: double\npickup_latitude: double\nrate_code: string\nstore_and_fwd: string\ndropoff_longitude: double\ndropoff_latitude: double\npayment_type: string\nfare_amount: double\nextra: double\nmta_tax: double\ntip_amount: double\ntolls_amount: double\ntotal_amount: double\nimprovement_surcharge: double\ncongestion_surcharge: double\npickup_location_id: int64\ndropoff_location_id: int64\nyear: int32\nmonth: int32\n```\n:::\n:::\n\n\n## Schema for the `nyc_taxi_zones` table\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrow_table(nyc_taxi_zones)$schema\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSchema\nlocation_id: int32\nborough: string\n```\n:::\n:::\n\n\n-   `pickup_location_id` is int64 in the `nyc_taxi` table\n-   `location_id` is int32 in the `nyc_taxi_zones` table\n\n## Take control of the schema\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi_zones_arrow <- arrow_table(\n  nyc_taxi_zones, \n  schema = schema(location_id = int64(), borough = utf8())\n)\n```\n:::\n\n\n-   `schema()` takes variable name / types as input\n-   {arrow} has various \"type\" functions: `int64()`, `utf8()`, `boolean()`, `date32()` etc\n\n## Take control of the schema\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi_zones_arrow <- arrow_table(\n  nyc_taxi_zones, \n  schema = schema(location_id = int64(), borough = utf8())\n)\nnyc_taxi_zones_arrow$schema\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSchema\nlocation_id: int64\nborough: string\n```\n:::\n:::\n\n\n## Prepare the auxiliary tables\n\n\n::: {.cell}\n\n```{.r .cell-code}\npickup <- nyc_taxi_zones_arrow |>\n  select(pickup_location_id = location_id,\n         pickup_borough = borough)\n\ndropoff <- nyc_taxi_zones_arrow |>\n  select(dropoff_location_id = location_id,\n         dropoff_borough = borough)\n```\n:::\n\n\n-   Join separately for the pickup and dropoff zones\n\n\n```{=html}\n<!-- \n    * simple example of a join\n    * show a join with unmatched schemas\n    * making the schemas match\n-->\n```\n\n## Join and cross-tabulate\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tictoc)\n\ntic()\nborough_counts <- nyc_taxi |> \n  left_join(pickup) |>\n  left_join(dropoff) |>\n  count(pickup_borough, dropoff_borough) |>\n  arrange(desc(n)) |>\n  collect()\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n93.217 sec elapsed\n```\n:::\n:::\n\n\n<br>\n\n2-3 minutes to join twice and cross-tabulate on non-partition variables, with 1.15 billion rows of data üôÇ\n\n## The results\n\n\n::: {.cell}\n\n```{.r .cell-code}\nborough_counts\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 √ó 3\n   pickup_borough dropoff_borough         n\n   <chr>          <chr>               <int>\n 1 <NA>           <NA>            732357953\n 2 Manhattan      Manhattan       351198872\n 3 Queens         Manhattan        14440705\n 4 Manhattan      Queens           13052517\n 5 Manhattan      Brooklyn         11180867\n 6 Queens         Queens            7440356\n 7 Unknown        Unknown           4491811\n 8 Queens         Brooklyn          3662324\n 9 Brooklyn       Brooklyn          3550480\n10 Manhattan      Bronx             2071830\n# ‚Ñπ 40 more rows\n```\n:::\n:::\n\n\n## Your Turn\n\n1.  How many taxi pickups were recorded in 2019 from the three major airports covered by the NYC Taxis data set (JFK, LaGuardia, Newark)?\n\n‚û°Ô∏è [Data Manipulation Part I Exercises Page](04-data-manipulation-2-exercises.html)\n\n# Window functions\n\n## What are window functions?\n\n-   calculations within groups\n\n## Grouped summaries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfare_by_year <- nyc_taxi %>%\n  filter(year %in% 2021:2022) %>%\n  select(year, fare_amount)\n\nfare_by_year %>%\n  group_by(year) %>%\n  summarise(mean_fare = mean(fare_amount)) %>% \n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 √ó 2\n   year mean_fare\n  <int>     <dbl>\n1  2021      13.5\n```\n:::\n:::\n\n\n## Window functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfare_by_year %>%\n  group_by(year) %>%\n  mutate(mean_fare = mean(fare_amount)) %>% \n  collect()\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: window functions not currently supported in Arrow\nCall collect() first to pull data into R.\n```\n:::\n:::\n\n\n## Window functions - via joins\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfare_by_year %>%\n  left_join(\n    nyc_taxi %>%\n      group_by(year) %>%\n      summarise(mean_fare = mean(fare_amount))\n  ) %>% \n  arrange(desc(fare_amount)) %>%\n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 30,902,618 √ó 3\n    year fare_amount mean_fare\n   <int>       <dbl>     <dbl>\n 1  2021     818283.      13.5\n 2  2021     398466.      13.5\n 3  2021     395854.      13.5\n 4  2021       6965       13.5\n 5  2021       6960.      13.5\n 6  2021       6010       13.5\n 7  2021       5954       13.5\n 8  2021       4969       13.5\n 9  2021       3555.      13.5\n10  2021       3009       13.5\n# ‚Ñπ 30,902,608 more rows\n```\n:::\n:::\n\n\n## Window functions - via duckdb\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfare_by_year %>%\n  group_by(year) %>%\n  to_duckdb() %>%\n  mutate(mean_fare = mean(fare_amount)) %>% \n  to_arrow() %>%\n  arrange(desc(fare_amount)) %>%\n  collect()\n```\n:::\n\n\n## Your Turn\n\n1.  How many trips in 2019 had a longer than average distance for that year?\n\n‚û°Ô∏è [Data Manipulation Part I Exercises Page](04-data-manipulation-2-exercises.html)\n\n## Custom functions\n\n-   Not officially supported\n-   Works for simple operations but not with bindings\n\n## Custom functions - supported\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmillions <- function(x) x / 10^6\n\nnyc_taxi |>\n  group_by(vendor_name) %>%\n  summarise(trips = n()) %>%\n  mutate(\n    trips_mil = millions(trips)\n  ) %>%\n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 √ó 3\n  vendor_name     trips trips_mil\n  <chr>           <int>     <dbl>\n1 CMT         530173884    530.  \n2 VTS         617481207    617.  \n3 <NA>          2697575      2.70\n```\n:::\n:::\n\n\n## Custom functions - not supported\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmorning <- function(x) ifelse(lubridate::am(x), \"morning\", \"afternoon\")\nnyc_taxi |>\n  group_by(morning(pickup_datetime)) %>%\n  count() %>%\n  collect()\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: Expression morning(pickup_datetime) not supported in Arrow\nCall collect() first to pull data into R.\n```\n:::\n:::\n\n\n-   recommendation: write code as dplyr expressions instead of functions, or look up docs on user-defined functions for datasets (see `?register_scalar_function`)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}