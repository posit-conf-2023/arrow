{
  "hash": "799c7a0d9463cc46726c86159a85bc2f",
  "result": {
    "markdown": "---\nfooter: \"[🔗 pos.it/arrow-conf23](https://pos.it/arrow-conf23)\"\nlogo: \"images/logo.png\"\nexecute:\n  echo: true\nformat:\n  revealjs: \n    theme: default\nengine: knitr\neditor: source\n---\n\n\n# Data Manipulation---Part 2 {#data-manip-2}\n\n\n::: {.cell}\n\n:::\n\n\n## What if a function binding doesn't exist - revisited!\n\n-   Option 1 - find a workaround\n-   Option 2 - user-defined functions (UDFs)\n\n## Why use a UDF?\n\nImplement your own custom functions!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntime_diff_minutes <- function(pickup, dropoff){\n  difftime(dropoff, pickup, units = \"mins\") |>\n      round() |>\n      as.integer()\n}\n\nnyc_taxi |>\n  mutate(\n    duration_minutes = time_diff_minutes(pickup_datetime, dropoff_datetime)\n  ) |> \n  select(pickup_datetime, dropoff_datetime, duration_minutes) |>\n  head() |>\n  collect()\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: Expression time_diff_minutes(pickup_datetime, dropoff_datetime) not supported in Arrow\nCall collect() first to pull data into R.\n```\n:::\n:::\n\n\nWe get an error as we can't automatically convert the function to arrow.\n\n# User-defined functions (aka UDFs)\n\n-   Define your own functions\n-   Scalar functions - 1 row input and 1 row output\n\n\n## User-defined functions - definition\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregister_scalar_function(\n  name = \"time_diff_minutes\",\n  function(context, pickup, dropoff) {\n    difftime(dropoff, pickup, units = \"mins\") |>\n      round() |>\n      as.integer()\n  },\n  in_type = schema(\n    pickup = timestamp(unit = \"ms\"),\n    dropoff = timestamp(unit = \"ms\")\n  ),\n  out_type = int32(),\n  auto_convert = TRUE\n)\n```\n:::\n\n\nThis looks complicated, so let's look at it 1 part at a time!\n\n## User-defined functions - definition\n\nStep 1. Give the function a name\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2\"}\nregister_scalar_function(\n  name = \"time_diff_minutes\",\n  function(context, pickup, dropoff) {\n    difftime(dropoff, pickup, units = \"mins\") |>\n      round() |>\n      as.integer()\n  },\n  in_type = schema(\n    pickup = timestamp(unit = \"ms\"),\n    dropoff = timestamp(unit = \"ms\")\n  ),\n  out_type = int32(),\n  auto_convert = TRUE\n)\n```\n:::\n\n\n## User-defined functions - definition\n\nStep 2. Define the body of the function - first argument *must* be `context`\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"3,4,5,6,7\"}\nregister_scalar_function(\n  name = \"time_diff_minutes\",\n  function(context, pickup, dropoff) {\n    difftime(dropoff, pickup, units = \"mins\") |>\n      round() |>\n      as.integer()\n  },\n  in_type = schema(\n    pickup = timestamp(unit = \"ms\"),\n    dropoff = timestamp(unit = \"ms\")\n  ),\n  out_type = int32(),\n  auto_convert = TRUE\n)\n```\n:::\n\n\n## User-defined functions - definition\n\nStep 3. Set the schema of the input arguments\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"8,9,10,11\"}\nregister_scalar_function(\n  name = \"time_diff_minutes\",\n  function(context, pickup, dropoff) {\n    difftime(dropoff, pickup, units = \"mins\") |>\n      round() |>\n      as.integer()\n  },\n  in_type = schema(\n    pickup = timestamp(unit = \"ms\"),\n    dropoff = timestamp(unit = \"ms\")\n  ),\n  out_type = int32(),\n  auto_convert = TRUE\n)\n```\n:::\n\n\n## User-defined functions - definition\n\nStep 4. Set the data type of the output\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"12\"}\nregister_scalar_function(\n  name = \"time_diff_minutes\",\n  function(context, pickup, dropoff) {\n    difftime(dropoff, pickup, units = \"mins\") |>\n      round() |>\n      as.integer()\n  },\n  in_type = schema(\n    pickup = timestamp(unit = \"ms\"),\n    dropoff = timestamp(unit = \"ms\")\n  ),\n  out_type = int32(),\n  auto_convert = TRUE\n)\n```\n:::\n\n\n## User-defined functions - definition\n\nStep 5. Set `auto_convert = TRUE` if using in a dplyr pipeline\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"13\"}\nregister_scalar_function(\n  name = \"time_diff_minutes\",\n  function(context, pickup, dropoff) {\n    difftime(dropoff, pickup, units = \"mins\") |>\n      round() |>\n      as.integer()\n  },\n  in_type = schema(\n    pickup = timestamp(unit = \"ms\"),\n    dropoff = timestamp(unit = \"ms\")\n  ),\n  out_type = int32(),\n  auto_convert = TRUE\n)\n```\n:::\n\n\n## User-defined functions - usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi |>\n  mutate(\n    duration_minutes = time_diff_minutes(pickup_datetime, dropoff_datetime)\n  ) |>\n  select(pickup_datetime, dropoff_datetime, duration_minutes) |>\n  head() |>\n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  pickup_datetime     dropoff_datetime    duration_minutes\n  <dttm>              <dttm>                         <int>\n1 2012-11-02 19:47:00 2012-11-02 20:16:00               29\n2 2012-11-02 19:47:07 2012-11-02 19:53:32                6\n3 2012-11-02 19:47:13 2012-11-02 19:53:31                6\n4 2012-11-02 19:47:35 2012-11-02 19:52:40                5\n5 2012-11-02 19:47:51 2012-11-02 20:00:19               12\n6 2012-11-02 19:48:00 2012-11-02 19:51:00                3\n```\n:::\n:::\n\n\n## Your Turn\n\n1.  Write a user-defined function which wraps the `stringr` function `str_replace_na()`, and use it to replace any `NA` values in the `vendor_name` column with the string \"No vendor\" instead. (Test it on the data from 2019 so you're not pulling everything into memory)\n\n➡️ [Data Manipulation Part II Exercises Page](4_data_manipulation_2-exercises.html)\n\n## Summary\n\n-   You can use UDFs to create your own bindings when they don't exist\n-   UDFs must be scalar (1 row in -\\> 1 row out) and stateless (no knowledge of other rows of data)\n-   Calculations done by R not Arrow, so slower than in-built bindings but still pretty fast\n\n# Joins\n\n## Joins\n\n![](images/joins.png)\n\n## Joining a reference table\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvendors <- tibble::tibble(\n  code = c(\"VTS\", \"CMT\", \"DDS\"),\n  full_name = c(\n    \"Verifone Transportation Systems\",\n    \"Creative Mobile Technologies\",\n    \"Digital Dispatch Systems\"\n  )\n)\n\nnyc_taxi |>\n  left_join(vendors, by = c(\"vendor_name\" = \"code\")) |>\n  select(vendor_name, full_name, pickup_datetime) |>\n  head(3) |>\n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  vendor_name full_name                    pickup_datetime    \n  <chr>       <chr>                        <dttm>             \n1 CMT         Creative Mobile Technologies 2012-01-20 08:09:36\n2 CMT         Creative Mobile Technologies 2012-01-20 08:54:10\n3 CMT         Creative Mobile Technologies 2012-01-20 02:08:01\n```\n:::\n:::\n\n\n## Traps for the unwary\n\nQuestion: which are the most common borough-to-borough journeys in the dataset?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi_zones <- \n  read_csv_arrow(here::here(\"data/taxi_zone_lookup.csv\")) |>\n  select(location_id = LocationID,\n         borough = Borough)\n\nnyc_taxi_zones\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 265 × 2\n   location_id borough      \n         <int> <chr>        \n 1           1 EWR          \n 2           2 Queens       \n 3           3 Bronx        \n 4           4 Manhattan    \n 5           5 Staten Island\n 6           6 Staten Island\n 7           7 Queens       \n 8           8 Queens       \n 9           9 Queens       \n10          10 Queens       \n# ℹ 255 more rows\n```\n:::\n:::\n\n\n## Why didn't this work?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi |>\n  left_join(nyc_taxi_zones, by = c(\"pickup_location_id\" = \"location_id\")) |>\n  collect()\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `compute.arrow_dplyr_query()`:\n! Invalid: Incompatible data types for corresponding join field keys: FieldRef.Name(pickup_location_id) of type int64 and FieldRef.Name(location_id) of type int32\n```\n:::\n:::\n\n\n## Schema for the `nyc_taxi` Dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\nschema(nyc_taxi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSchema\nvendor_name: string\npickup_datetime: timestamp[ms]\ndropoff_datetime: timestamp[ms]\npassenger_count: int64\ntrip_distance: double\npickup_longitude: double\npickup_latitude: double\nrate_code: string\nstore_and_fwd: string\ndropoff_longitude: double\ndropoff_latitude: double\npayment_type: string\nfare_amount: double\nextra: double\nmta_tax: double\ntip_amount: double\ntolls_amount: double\ntotal_amount: double\nimprovement_surcharge: double\ncongestion_surcharge: double\npickup_location_id: int64\ndropoff_location_id: int64\nyear: int32\nmonth: int32\n```\n:::\n:::\n\n\n## Schema for the `nyc_taxi_zones` Table\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi_zones_arrow <- arrow_table(nyc_taxi_zones)\nschema(nyc_taxi_zones_arrow)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSchema\nlocation_id: int32\nborough: string\n```\n:::\n:::\n\n\n-   `pickup_location_id` is int64 in the `nyc_taxi` table\n-   `location_id` is int32 in the `nyc_taxi_zones` table\n\n## Take control of the schema\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi_zones_arrow <- arrow_table(\n  nyc_taxi_zones, \n  schema = schema(location_id = int64(), borough = utf8())\n)\n```\n:::\n\n\n-   `schema()` takes variable name / types as input\n-   arrow has various \"type\" functions: `int64()`, `utf8()`, `boolean()`, `date32()` etc\n\n## Take control of the schema\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnyc_taxi_zones_arrow <- arrow_table(\n  nyc_taxi_zones, \n  schema = schema(location_id = int64(), borough = utf8())\n)\nschema(nyc_taxi_zones_arrow)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSchema\nlocation_id: int64\nborough: string\n```\n:::\n:::\n\n\n## Prepare the auxiliary tables\n\n\n::: {.cell}\n\n```{.r .cell-code}\npickup <- nyc_taxi_zones_arrow |>\n  select(pickup_location_id = location_id,\n         pickup_borough = borough)\n\ndropoff <- nyc_taxi_zones_arrow |>\n  select(dropoff_location_id = location_id,\n         dropoff_borough = borough)\n```\n:::\n\n\n-   Join separately for the pickup and dropoff zones\n\n\n## Join and cross-tabulate\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tictoc)\n\ntic()\nborough_counts <- nyc_taxi |> \n  left_join(pickup) |>\n  left_join(dropoff) |>\n  count(pickup_borough, dropoff_borough) |>\n  arrange(desc(n)) |>\n  collect()\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n131.403 sec elapsed\n```\n:::\n:::\n\n\n<br>\n\n2-3 minutes to join twice and cross-tabulate on non-partition variables, with 1.15 billion rows of data 🙂\n\n## The results\n\n\n::: {.cell}\n\n```{.r .cell-code}\nborough_counts\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 × 3\n   pickup_borough dropoff_borough         n\n   <chr>          <chr>               <int>\n 1 <NA>           <NA>            732357953\n 2 Manhattan      Manhattan       351198872\n 3 Queens         Manhattan        14440705\n 4 Manhattan      Queens           13052517\n 5 Manhattan      Brooklyn         11180867\n 6 Queens         Queens            7440356\n 7 Unknown        Unknown           4491811\n 8 Queens         Brooklyn          3662324\n 9 Brooklyn       Brooklyn          3550480\n10 Manhattan      Bronx             2071830\n# ℹ 40 more rows\n```\n:::\n:::\n\n\n## Your Turn\n\n1.  How many taxi pickups were recorded in 2019 from the three major airports covered by the NYC Taxis data set (JFK, LaGuardia, Newark)? (Hint: you can use `stringr::str_detect()` to help you find pickup zones with the word \"Airport\" in them)\n\n➡️ [Data Manipulation Part II Exercises Page](4_data_manipulation_2-exercises.html)\n\n## Summary\n\n-   You can join Arrow Tables and Datasets to R data frames and Arrow Tables\n-   The Arrow data type of join keys must always match\n\n# Window functions\n\n## What are window functions?\n\n-   calculations across a \"window\" of multiple rows which relate to the current row\n-   e.g. `row_number()`, `ntile()`, or calling `mutate()` after `group_by()`\n\n## Grouped summaries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfare_by_year <- nyc_taxi |>\n  filter(year > 2019) |>\n  select(year, fare_amount)\n\nfare_by_year |>\n  group_by(year) |>\n  summarise(mean_fare = mean(fare_amount)) |> \n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n   year mean_fare\n  <int>     <dbl>\n1  2020      12.7\n2  2021      13.5\n```\n:::\n:::\n\n\n## Window functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfare_by_year |>\n  group_by(year) |>\n  mutate(mean_fare = mean(fare_amount)) |> \n  head() |> \n  collect()\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: window functions not currently supported in Arrow\nCall collect() first to pull data into R.\n```\n:::\n:::\n\n\n## Window functions - via joins\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfare_by_year |>\n  left_join(\n    fare_by_year |>\n      group_by(year) |>\n      summarise(mean_fare = mean(fare_amount))\n  ) |> \n  arrange(desc(fare_amount)) |>\n  head() |> \n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n   year fare_amount mean_fare\n  <int>       <dbl>     <dbl>\n1  2020     998310.      12.7\n2  2021     818283.      13.5\n3  2020     671100.      12.7\n4  2020     429497.      12.7\n5  2021     398466.      13.5\n6  2020     398465.      12.7\n```\n:::\n:::\n\n\n## Window functions - via duckdb\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfare_by_year |>\n  group_by(year) |>\n  to_duckdb() |>\n  mutate(mean_fare = mean(fare_amount)) |> \n  to_arrow() |>\n  arrange(desc(fare_amount)) |>\n  head() |>\n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n   year fare_amount mean_fare\n  <int>       <dbl>     <dbl>\n1  2020     998310.      12.7\n2  2021     818283.      13.5\n3  2020     671100.      12.7\n4  2020     429497.      12.7\n5  2021     398466.      13.5\n6  2020     398465.      12.7\n```\n:::\n:::\n\n\n## Your Turn\n\n1.  How many trips in September 2019 had a longer than average distance for that month?\n\n➡️ [Data Manipulation Part II Exercises Page](4_data_manipulation_2-exercises.html)\n\n## Summary\n\n-   Window functions in arrow can be achieved via joins or passing data to and from duckdb\n",
    "supporting": [
      "4_data_manipulation_2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}